// deno run --allow-read --allow-write scripts/generate-lts.ts
//

interface NodeReleaseMetadata {
  version: string;
  date: string;
  files: string[];
  npm?: string;
  v8: string;
  uv?: string;
  zlib?: string;
  openssl?: string;
  modules?: string;
  lts: string | boolean;
  security: boolean;
}

type CombinedConfigInput = {
  base: string;
  extends: [...string[]];
  name: string;
};

type Tsconfig = Record<string, any>;

const versionRegex = /v(\d+)\.(\d+)\.(\d+)/;

function calcVersion(x: string) {
  const match = x.match(versionRegex);
  if (!match) {
    throw new Error(`version regex failed to match version string '${x}'`);
  }
  return +match[1] * 1000000 + +match[2] * 1000 + +match[3];
}

const releasesResponse = await fetch("https://nodejs.org/download/release/index.json");
const releasesJson = (await releasesResponse.json()) as NodeReleaseMetadata[];
const lts = releasesJson
  .filter((r) => r.lts)
  .reduce(
    (prevValue, currValue) => (calcVersion(currValue.version) > calcVersion(prevValue.version) ? currValue : prevValue),
    {
      version: "v0.0.0"
    }
  );
const baseMajorVersion = (lts.version.match(versionRegex) || [])[1];
const base = `node${baseMajorVersion}`;
const name = "node-lts";
const versioned = {
  $schema: "https://json.schemastore.org/tsconfig",
  display: "Node LTS",
  _version: lts.version.substring(lts.version.indexOf("v") + 1)
};

const inputs: CombinedConfigInput[] = [
  { base, extends: ["esm", "strictest"], name },
  { base, extends: ["strictest"], name },
  { base, extends: [], name }
];

import * as path from "https://deno.land/std/path/mod.ts";
import stripJsonComments from "https://esm.sh/strip-json-comments";
import { deepMerge } from "https://deno.land/std/collections/deep_merge.ts";

function merge(configs: readonly Tsconfig[]): Tsconfig {
  let result: Tsconfig = {};

  for (const config of configs) {
    result = deepMerge(result, config);
  }

  result.display = configs.map((x) => x.display).join(" + ");

  return result;
}

function writeCombinedConfig(input: CombinedConfigInput, config: Tsconfig): Promise<void> {
  const filePath =
    input.extends.length > 0
      ? path.join(Deno.cwd(), "bases", `${input.name}-${[...input.extends].reverse().join("-")}.combined.json`)
      : path.join(Deno.cwd(), "bases", `${input.name}.json`);
  const serializedConfig =
    "// This file was autogenerated by a script\n" +
    `// Equivalent to a config of: ${[input.base, ...input.extends].reverse().join(" extends ")}\n` +
    JSON.stringify(config, null, "  ");

  return Deno.writeTextFile(filePath, serializedConfig);
}

const configCache: Map<string, Tsconfig> = new Map();

// Populate configs cache
for (const input of new Set(inputs.map((x) => [x.base, x.extends]).flat(2))) {
  const packageText = await Deno.readTextFile(path.join(Deno.cwd(), "bases", `${input}.json`));

  const parsed = JSON.parse(stripJsonComments(packageText)) as Tsconfig;

  // This is to get the _version property to show up directly under the display property
  configCache.set(input, deepMerge(versioned, parsed));
}

const mergedConfigs: Map<CombinedConfigInput, Tsconfig> = new Map();

for (const input of inputs) {
  const configs = [input.base, ...input.extends].map((name) => {
    const c = configCache.get(name)!;
    if (name === input.base) {
      c.display = "Node LTS";
    }
    return c;
  });

  const merged = merge(configs);

  mergedConfigs.set(input, merged);
}

await Promise.all([...mergedConfigs].map(([names, config]) => writeCombinedConfig(names, config)));
